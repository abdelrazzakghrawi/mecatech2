<<<<<<< HEAD
import { type BSONSerializeOptions, type Document, resolveBSONOptions } from '../bson';
import { ReadPreference, type ReadPreferenceLike } from '../read_preference';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import type { MongoDBNamespace } from '../utils';
=======
import { promisify } from 'util';

import { BSONSerializeOptions, Document, resolveBSONOptions } from '../bson';
import { ReadPreference, ReadPreferenceLike } from '../read_preference';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import type { Callback, MongoDBNamespace } from '../utils';
>>>>>>> 95d78a85bed1dbb235176af051af02a51b0c87bd

export const Aspect = {
  READ_OPERATION: Symbol('READ_OPERATION'),
  WRITE_OPERATION: Symbol('WRITE_OPERATION'),
  RETRYABLE: Symbol('RETRYABLE'),
  EXPLAINABLE: Symbol('EXPLAINABLE'),
  SKIP_COLLATION: Symbol('SKIP_COLLATION'),
  CURSOR_CREATING: Symbol('CURSOR_CREATING'),
  MUST_SELECT_SAME_SERVER: Symbol('MUST_SELECT_SAME_SERVER')
} as const;

/** @public */
export type Hint = string | Document;

<<<<<<< HEAD
// eslint-disable-next-line @typescript-eslint/ban-types
export interface OperationConstructor extends Function {
  aspects?: Set<symbol>;
}

=======
>>>>>>> 95d78a85bed1dbb235176af051af02a51b0c87bd
/** @public */
export interface OperationOptions extends BSONSerializeOptions {
  /** Specify ClientSession for this command */
  session?: ClientSession;
  willRetryWrite?: boolean;

  /** The preferred read preference (ReadPreference.primary, ReadPreference.primary_preferred, ReadPreference.secondary, ReadPreference.secondary_preferred, ReadPreference.nearest). */
  readPreference?: ReadPreferenceLike;

  /** @internal Hints to `executeOperation` that this operation should not unpin on an ended transaction */
  bypassPinningCheck?: boolean;
  omitReadPreference?: boolean;
<<<<<<< HEAD

  /** @internal TODO(NODE-5688): make this public */
  timeoutMS?: number;
=======
>>>>>>> 95d78a85bed1dbb235176af051af02a51b0c87bd
}

/** @internal */
const kSession = Symbol('session');

/**
 * This class acts as a parent class for any operation and is responsible for setting this.options,
 * as well as setting and getting a session.
 * Additionally, this class implements `hasAspect`, which determines whether an operation has
 * a specific aspect.
 * @internal
 */
export abstract class AbstractOperation<TResult = any> {
  ns!: MongoDBNamespace;
<<<<<<< HEAD
=======
  cmd!: Document;
>>>>>>> 95d78a85bed1dbb235176af051af02a51b0c87bd
  readPreference: ReadPreference;
  server!: Server;
  bypassPinningCheck: boolean;
  trySecondaryWrite: boolean;

  // BSON serialization options
  bsonOptions?: BSONSerializeOptions;

  options: OperationOptions;

  [kSession]: ClientSession | undefined;

<<<<<<< HEAD
  constructor(options: OperationOptions = {}) {
=======
  executeAsync: (server: Server, session: ClientSession | undefined) => Promise<TResult>;

  constructor(options: OperationOptions = {}) {
    this.executeAsync = promisify(
      (
        server: Server,
        session: ClientSession | undefined,
        callback: (e: Error, r: TResult) => void
      ) => {
        this.execute(server, session, callback as any);
      }
    );

>>>>>>> 95d78a85bed1dbb235176af051af02a51b0c87bd
    this.readPreference = this.hasAspect(Aspect.WRITE_OPERATION)
      ? ReadPreference.primary
      : ReadPreference.fromOptions(options) ?? ReadPreference.primary;

    // Pull the BSON serialize options from the already-resolved options
    this.bsonOptions = resolveBSONOptions(options);

    this[kSession] = options.session != null ? options.session : undefined;

    this.options = options;
    this.bypassPinningCheck = !!options.bypassPinningCheck;
    this.trySecondaryWrite = false;
  }

<<<<<<< HEAD
  /** Must match the first key of the command object sent to the server.
  Command name should be stateless (should not use 'this' keyword) */
  abstract get commandName(): string;

  abstract execute(server: Server, session: ClientSession | undefined): Promise<TResult>;

  hasAspect(aspect: symbol): boolean {
    const ctor = this.constructor as OperationConstructor;
=======
  abstract execute(
    server: Server,
    session: ClientSession | undefined,
    callback: Callback<TResult>
  ): void;

  hasAspect(aspect: symbol): boolean {
    const ctor = this.constructor as { aspects?: Set<symbol> };
>>>>>>> 95d78a85bed1dbb235176af051af02a51b0c87bd
    if (ctor.aspects == null) {
      return false;
    }

    return ctor.aspects.has(aspect);
  }

  get session(): ClientSession | undefined {
    return this[kSession];
  }

  clearSession() {
    this[kSession] = undefined;
  }

  get canRetryRead(): boolean {
    return true;
  }

  get canRetryWrite(): boolean {
    return true;
  }
}

export function defineAspects(
<<<<<<< HEAD
  operation: OperationConstructor,
=======
  operation: { new (...args: any[]): any },
>>>>>>> 95d78a85bed1dbb235176af051af02a51b0c87bd
  aspects: symbol | symbol[] | Set<symbol>
): Set<symbol> {
  if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
    aspects = [aspects];
  }

  aspects = new Set(aspects);
  Object.defineProperty(operation, 'aspects', {
    value: aspects,
    writable: false
  });

  return aspects;
}
